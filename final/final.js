/*globals define*/
function process(name,targetNamespace,xmlns,matter){
    var result = "<process name=\""+name+"\" targetNamespace=\""+targetNamespace+"\" xmlns=\""+xmlns+"\" >\n\t" + matter+ "\n</process>";
    return result;
}
function parterner_link(name,partnerLinkType,myRole,partnerRole){
    var result = "<partnerLink name=\"" + String(name)+"\" partnerLinkType=\""+partnerLinkType+"\" myRole=\""+myRole+"\" partnerRole=\""+partnerRole+"\"/>";
    return result;
}
function parterner_links(matter){
    var result = "<partnerLinks>\n\t"+matter +"\n</partnerLinks>";
    return result;
}
function variables(matter){
    var result = "<variables>\n\t"+matter +"\n</variables>";
    return result;
}
function variable(name,messageType){
    var result = "<variable name=\""+name+"\" messageType=\""+messageType+"\"/>\n";
    return result;
}
function sequence(matter){
    var result = "<sequence>\n\t"+matter+"\n</sequence>";
    return result;
}
function invoke(partnerLink,portType,operation,inputVariable,outputVariable){
    var result =  "<invoke partnerLink=\""+partnerLink+"\" portType=\""+portType+"\" operation=\""+operation+"\" inputVariable=\""+inputVariable+"\" outputVariable=\""+outputVariable+"\"/>\n";
    return result;
}
function recive(partnerLink,portType,operation,variable){
    var result = "<receive partnerLink=\""+partnerLink+"\" portType=\""+portType+"\" operation=\""+operation+"\" variable=\""+variable+"\" />";
    return result;
}
function assign(from ,to ){
    var result = "<assign>\n<copy>\n<from variable=\""+from +"\"/>\n<to variable=\""+to+"\"/>\n</copy>\n</assign>\n";
    return result;
}
function _switch(matter){
    var result = "<switch>\n\t"+matter+"\n</switch>";
    return result;
}
function otherwise(matter){
    var result = "<otherwise>\n\t"+matter+"\n</otherwise>";
    return result;
}
function _case(condition,matter){
    var result = "<case condition=\""+condition+"\">\n\t" +matter+"\n</case>";
    return result;
}
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Thu Apr 14 2022 13:45:22 GMT+0530 (India Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of final.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin final.
     * @constructor
     */
    function final() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    final.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    final.prototype = Object.create(PluginBase.prototype);
    final.prototype.constructor = final;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    final.prototype.main = function (callback) {
        // Use this to access core, project, result, logger etc from PluginBase.
        const self = this;

        // Using the logger.
        self.logger.debug('This is a debug message.');
        self.logger.info('This is an info message.');
        self.logger.warn('This is a warning message.');
        self.logger.error('This is an error message.');

        // Using the coreAPI to make changes.
        const nodeObject = self.activeNode;
        var plnks ="";
        var _variable = "";
        var seq = "";
        var graph = {};
        var vis = {};
        var root;
        var getVariables = new Set();
        console.log(self.core.getAttribute(nodeObject,"name"));
        self.loadNodeMap(nodeObject)
        .then((nodes)=>{
            const cp = self.core.getChildrenPaths(nodeObject);
            for(var i = 0 ;i<cp.length;i++){
                var node = nodes[cp[i]];
                var metaType = String(self.core.getMetaType(nodes[cp[i]]).data.atr.name);
                if(!self.core.isConnection(nodes[cp[i]])){
                    if(metaType.localeCompare("Partner link") == 0){
                        console.log("Heey")
                        const name = self.core.getAttribute(node,'name');
                        const myRole = self.core.getAttribute(node,'name'); 
                        const partnerLinkType = self.core.getAttribute(node,'name'); 
                        const partnerRole = self.core.getAttribute(node,'name'); 
                        plnks += parterner_link(name,partnerLinkType,myRole,partnerRole);
                    }
                    if(metaType.localeCompare("Invoke") == 0){
                        var  inputVariable = self.core.getAttribute(node,"inputVariable");
                        var  outputVariable = self.core.getAttribute(node,"outputVariable");
                        getVariables.add(inputVariable);
                        getVariables.add(outputVariable);
                    }
                    if(metaType.localeCompare("Assign") == 0){
                        var from = self.core.getAttribute(node,"from");
                        var to = self.core.getAttribute(node,"to");
                        getVariables.add(from);
                        getVariables.add(to);
                    }
                    if(metaType.localeCompare("Start")== 0){
                        root = cp[i];
                    }
                }else{
                   // var node = nodes[cp[i]];
                    if(metaType.localeCompare("connection") == 0){
                        var x = self.core.getPointerPath(node,'src');
                        var y = self.core.getPointerPath(node,'dst');
                        vis[x] = false;
                        vis[y] = false;
                        if(!(x in graph)){
                            graph[x] = [];
                        }
                        graph[x].push(y);
                    }
                }
            }
            function dfs(x){
                vis[x] = true;
                //console.log(self.core.getAttribute(nodes[x],'name'));
                //console.log(vis);
                //console.log(graph);

                //console.log(graph);
                graph[x].forEach((child, i) => {
                    if(!vis[child]){
                        var currnode = nodes[child]; 
                        var metaType = String(self.core.getMetaType(currnode).data.atr.name);
                        console.log(self.core.getAttribute(currnode,'name'));
                        if(metaType.localeCompare("Invoke")==0){
                            var inputVariable = self.core.getAttribute(currnode,"inputVariable");
                            var name = self.core.getAttribute(currnode,"name");
                            var operation = self.core.getAttribute(currnode,"operation");
                            var outputVariable = self.core.getAttribute(currnode,"outputVariable");
                            var partnerLink = self.core.getAttribute(currnode,"partnerLink");
                            var portType = self.core.getAttribute(currnode,"portType");
                            seq += invoke(partnerLink,portType,operation,inputVariable,outputVariable);
                        }
                        if(metaType.localeCompare("Assign")==0){
                            var from = self.core.getAttribute(currnode,"from");
                            var to = self.core.getAttribute(currnode,"to");
                            seq += assign(from,to);
                        }
                        if((child in graph)){
                            dfs(child);
                        }else{
                            vis[child] = true;
                        }
                    }
                });
            }
            console.log(typeof(root));
            console.log("HHHH");
            dfs(root);
            console.log("HHHH");

            //console.log(graph);
            getVariables.forEach((val)=>{
                _variable += variable(val,"");
            });
            plnks = parterner_links(plnks);
            _variable = variables(_variable);
            seq = sequence(seq);
            var code = process(self.core.getAttribute(nodeObject,"name"),"","",plnks+"\n"+_variable+"\n"+seq);
            console.log(code);
            console.log("code");

        });
        
        // This will save the changes. If you don't want to save;
        // exclude self.save and call callback directly from this scope.
        self.save('final updated model.')
            .then(() => {
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch((err) => {
                // Result success is false at invocation.
                self.logger.error(err.stack);
                callback(err, self.result);
            });
    };

    return final;
});
